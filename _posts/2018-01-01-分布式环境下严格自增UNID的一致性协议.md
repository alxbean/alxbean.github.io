### 分布式环境下严格自增UNID的一致性协议——lax

 在当前的生产环境中，总是需要一个UNID来统筹整个分布式环境中的资源，保证系统的高效稳定运行。业界已经出现了不少ID生成算法，比较有名的如twitter的snowflake，Chaos的十进制ID生成算法，还有UUID等。通常情况下，客户端通过ID服务器来获取全局唯一的ID，因此ID服务器的高性能和高可用是保证整个业务系统稳定运转的重要一环。本文将描述一种简单的一致性协议，保证严格自增的UNID服务器在分布式环境下，协同工作，从而保证ID服务器的高性能和高可用。

#### 总体架构

![lax总体架构](https://raw.githubusercontent.com/alxbean/alxbean.github.io/master/assets/lax/lax%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84.png)

lax的总体架构如上图所示，主要有三个部分组成，Tracker，Client，lax节点。

* Tracker

Tracker是一个broker，负责维护所有lax节点的状态，并向客户端提供lax节点请求查询服务及负载均衡。

* Client

客户端是获取自增UNID的唯一接口，并且可以提供http服务。

* Lax节点

Lax节点是自增UNID的服务节点，同一集群的节点间通过一致性协议进行ID的同步，保证ID的单调自增性，同时单个节点是不存在状态的，通过主主模式，每个节点都能提供ID服务，从而提高服务性能。同样的，任一节点宕机，只要整个集群一半以上的节点存活，服务仍可以持续提供，而且宕机节点可以随时上线，不影响整个集群的状态。

#### ID一致性

众所周知，数据一致性是分布式系统中的一个难题，在我们的lax架构中也不例外。lax中的ID算法是生成对某个key唯一的自增数据（全局唯一序列号，版本号），核心问题是保证数据的单调性。

| lax_A     | lax_B     | lax_C     | Result |
| --------- | --------- | --------- | ------ |
| 0->1      | 0->1      | 0->1      | 1      |
| 1->2      | FAILD->1  | 1->2      | 2      |
| FAILED->2 | 1->3      | 2->3      | 3      |
| 2->4      | FAILED->3 | FAILED->3 | FAILED |
| 4->5      | 3->5      | 3->5      | 5      |

laxA，B，C三个节点的状态变化如上所示，

1. 首先A，B，C初始化为0

2. 发出请求，查询最大ID为0，在所有节点上设置新ID为最大1，均成功返回，得到ID为1

3. 查询所有节点，最大ID为1，在所有节点上设置新ID为2，A，C设置成功，B节点失败，大于一半节点，仍然成功返回最大ID为2

4. 查询所有节点，A节点FAILED，B节点为1，C节点为2，最大ID为2，在所有节点上设置新ID为3；B, C设置成功，A设置失败，大于一半节点，仍然返回最大ID为3

5. 查询所有节点，得到最大节点为3，设置最新ID为4，A成功，B, C失败，成功节点少于一半，返回失败

6. 查询所有节点，得到最大节点为4，最新ID为5，A, B, C节点均设置成功，成功返回新ID为5

#### lax的生命周期

![lax生命周期](https://raw.githubusercontent.com/alxbean/alxbean.github.io/master/assets/lax/lax%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

lax节点的一次ID请求的生命周期主要有6个部分：**初始化**，**获取锁**，**查询最大ID**，**设置最新ID**，**释放锁**，**返回请求**。这6个生命周期的实现lax节点并且保证提供高效服务的至关重要的流程。

* **Init**

初始化过程，主要初始化本次请求的一些元数据信息，解析key值，定位数据文件，启动生命周期等。

* **获取锁**

被请求的lax节点向集群中的其他节点发出trylock请求，并在控制相应节点上的数据文件的写入状态。若能够获取大部分锁，则进入下一步，否则释放锁向客户端返回失败请求。

* **查询最大ID**

成功获取大部分锁后，分别向锁定节点发出ID查询请求，并获得当前最大ID。若能够获取大部分ID则成功，并进入下一步，否则释放锁并向客户端返回失败请求。

* **设置最大ID**

成功获取最大ID后，向锁定节点写入最新ID，若大部分返回成功，则进入下一步，否则释放锁并向客户端返回失败请求。

* **释放锁**


* **返回客户请求**

#### 总结

通过lax生成的单调递增ID，可以为我们的存储服务提供版本号支持。由于其逻辑简，且采用主主模式提供分布式的服务，具有非常出色的服务性能，在少量性能并不出色的机器上可以提供1W+的QPS，对硬件性能要求极低，尤其是内存，几乎可以忽略不计。此外，由于采用了分布式的架构，任一节点的宕机，不会影响整体的集群的服务和性能。在保证大部分节点正常工作的情况下，支持任一节点的热插拔。