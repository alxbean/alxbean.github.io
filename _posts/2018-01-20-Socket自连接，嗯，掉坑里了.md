上周完成了lax项目的节点恢复功能，并实现了相应的客户端。在通过客户端进行性能测试时总是时不时的爆出异常情况，导致测试终止。客户端和服务器通过TCP协议通信，并设计了相应的通讯协议如下：

~~~
Message := MsgHead + MsgBody
MsgHead := protocol + version + bodylen
~~~

#### 测试环境

由于是在开发环境的测试，所以只在一台物理机上启动了3个服务节点，并设置了不同的端口，并且在同一台机器上跑了客户端测试（嗯，坑已挖好）

#### 异常表现

启动客户端程序，获取1W个ID，然后随机终止一个服务器节点（7777端口），大约过3～5s后，客户端将有50%的概率异常终止（重新连接上了7777端口，并获取了错误的数据）

#### 异常分析

通过客户端终止前的异常日志发现，服务器端发过来的数据出现了问题，bodylen=15明显是一个异常的值（根据我们服务器端的逻辑，bodylen不可能是15）。根据这个线索，回头又去检查了服务器程序的相关发送日志，神奇的现象发生了，服务器端根本就没有发出过这个bodylen=15的TCP信息。WTF！那么问题出在了哪里？不是服务器是谁给客户端回复了信息？

嗯，那就tcpdump在抓包看看，到底是谁发的数据，通过分析发现，在7777端口的服务器程序被终止后，过3～5s，居然又从7777端口发出了bodylen=15的数据包😯，一脸懵逼。。。见鬼了么～

同时通过netstat监控了服务端口的情况，一切正常，等等，一条异常信息闪现而过

~~~
Local Address:127.0.0.1:7777             Foreign Address:127.0.0.1:7777
~~~

是什么？

是时候祭出大招了，gdb客户端程序，设定断点条件为bodylen=15，再次启动测试，终止7777端口的服务器程序后，3～5s后，gdb断点停下，真相大白：由于服务端程序设定了SO_REUSEADDR属性，导致了7777端口结束后立马可以被重用，而且我们服务器程序和客户端程序在同一台物理机上，导致了客户端的有一定概率分配到7777端口，而这时由于我们的tracker(代理服务器)上，7777服务器的信息尚未过期，再客户端向其发起请求时，恰好返回了127.0.0.1:7777的服务器地址，然而此时的7777非彼时的7777，而是客户端自身，相当于客户端自身向自身发起了链接，并发送了数据请求，又由于客户端和服务器端的协议处理逻辑一致，导致了数据解析并未发生异常，直到最终解析body数据时才发生异常。真是一个神奇的bug！当然线上环境不会出现这样的异常，因为服务器程序和客户端都是分离部署，不会出现这么多的巧合情况。

要避免自连接的问题，需要在程序逻辑加上getsockname和getpeername的地址结构的检查。参考知乎问题：[Linux下connect函数端口连到自己, 这种问题怎么解决?](https://www.zhihu.com/question/21517236)

 #### 花絮

这个问题看似简单，却逃过了和同事分析下来的各种场景，包括了socket链接的4次分手过程，TIME_WAIT状态，LAST_ACK未接收到的处理场景，FIN和RST的区别和使用场景，程序异常中断后内核对socket链接的处理，关于SO_REUSEADDR选项的设置，SO_LINGER 选项的设置等等，不管怎么说，又淌过一个坑。

