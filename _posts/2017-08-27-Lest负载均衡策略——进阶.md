
lest是我们开发的一款基于分布式文件系统的主动缓存系统。在最近的一次大量数据访问的情况下，发现storage存储节点间的数据流量差异显著。有的节点CPU打到了100%，而有的节点却只有10%都不到。显然，当前的存储节点间存在负载不均衡的问题。

![lest arch](https://github.com/alxbean/alxbean.github.io/blob/master/assets/lest/lest%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png?raw=true)

#### 以前的负载均衡策略

lest的负载均衡策略分为两级，第一级是同步组间的负载均衡，第二级是同步组内的负载均衡。我们这次线上发现的问题就是同步组内负载不均衡。数据的散列随机性是通过key根据hash算法得到一个随机值，该值的随机性决定了负载的均衡性。我们采用了PJW哈希算法来获取随机值，在一般情况下，可以获得较好的散列性。

那么问题出在了哪里？

![balnce](https://raw.githubusercontent.com/alxbean/alxbean.github.io/master/assets/lest/lest%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png)

通过对业务的仔细分析，我们发现当前的key值是根据业务的特性来构造的，如A业务总是以1结尾，B业务总是以2结尾，从而可以通过key值方便的区分业务的属性，而且在分库分表的设计中也非常方便。而业务往往是不均衡的，在极端情况下，A业务占到了总业务的99%，B业务仅占到了1%，这就直接导致了以1结尾的key值数量碾压了2结尾的key值数量。由于PJW算法的特性，以2结尾的hash值都是偶数，以1结尾的hash值都是奇数。历史上的灾难发生，往往都具备偶然性。我们线上的同步组恰恰都设置了2个节点。也就是说，所有的A业务刚好都被打到了奇节点，B业务都被打到了偶节点。如果线上配置了每个同步组3个节点就可以完美的避开这个问题，不过作为技术屌丝还是庆幸碰上了这个问题。

#### 解决方案

通过以上分析，我们了解到，这并不是某一个点的问题，而是一系列流程碰撞的结果。因此只要可以调整流程中任一阶段的处理方案，就可以解决问题。对以上流程，我们可以分成3个阶段，第一阶段是业务阶段，也即产生key值的阶段；第二阶段是hash阶段，产生hash值的阶段；第三阶段是映射阶段，将hash值映射到节点的阶段。业务阶段已经定型，我们无法变更，因此只有第二和第三阶段有操作空间。第二阶段的调整可以通过替换hash算法来完成。不过尝试了几种hash算法，效果并不理想，要么散列性不好，要么仍然存在同样的问题，遂放弃。最后，只能考虑第三阶段，能不能从hash映射的角度上解决问题。

#### 虚拟节点

![](https://github.com/alxbean/alxbean.github.io/blob/master/assets/lest/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9.png?raw=true)

对于第三阶段hash映射的问题，无非就是调整节点的storage节点的个数，使得它>=3就可以避免以上的问题。然而我们的生产环境已经搭建完毕，新增节点，重新部署会带来不少麻烦。在一致性哈希算法中有提到虚拟节点的概念，借鉴这个概念，我们考虑新增的节点为当前节点的虚拟节点，可以通过配置文件来调整整个哈希空间的节点数，继而调整key值在hash环上的映射关系，从而使得key值的映射更加均衡。上图中A，B是实体节点，A1，A2和B1，B2分别是A和B的虚拟节点。

#### 乱序还是顺序

在添加虚拟节点的时候有一个问题，是混乱添加还是顺序添加。从直观的角度来看混乱添加效果是最好的，貌似可以使得key值的散落的均衡性更好。然而由于tracker上管理node节点的数据结构的特殊性，实现这样的一个混乱哈希环的结构具有较高的复杂性，而且需要storage端的服务支持，变动较大。

![](https://github.com/alxbean/alxbean.github.io/blob/master/assets/lest/%E6%B7%B7%E4%B9%B1%E8%8A%82%E7%82%B9.png?raw=true)

其实，静下来想想，key值散落的随机性，并不会因为散落的节点混乱而更加随机，因为它们的随机性往往是通过hash算法来保证的，混乱的哈希环并不会是得key散落更加随机。从概率的角度来看，如果hash算法够随机，那么散落在每一个节点上的概率应该是相同的，如果是6个节点，那么每个节点上命中的概率应该是1/6，所以，它们应该是顺序无关的。如此，我们只需要在tracker上的node结构上添加一个虚拟节点数组即可，无需过多的操作，大大降低了程序的复杂性。

![](https://github.com/alxbean/alxbean.github.io/blob/master/assets/lest/%E9%A1%BA%E5%BA%8F%E8%8A%82%E7%82%B9.png?raw=true)

#### 实验结果

| 数据类型和数量         | 原来的策略            | 新策略                |
| --------------- | ---------------- | ------------------ |
| xxxxxxxx1:10000 | A节点:10000, B节点:0 | A节点:4432, B节点:5569 |
| xxxxxxxx2:10000 | A节点:0, B节点:10000 | A节点:5457, B节点:4544 |



根据以上实验结果，亲测有效。
