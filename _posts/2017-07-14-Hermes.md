# Hermes

## 简介

Hermes解决了不同环境下对象数据传输和存储的问题。它是基于MessagePack二进制序列化协议开发的一款可以支持java对象序列化，并在C服务器端可以构建树形结构对象的面向二进制数据对象的传输和存储协议。通过在C服务器端构建对象树结构来映射java端的类对象，从而简化了服务器端的对象数据处理。其中MesspackPack是一个比Json更加轻量级的序列化协议，有利于数据的传输和存储。

## 设计背景

Hermes协议的设计源于我们Lest项目中的对数据高效传输和存储的需求。Lest是我们设计开发的一款去内存化的分布式缓存系统，为了提升缓存的效率，我们需要对数据传输和存储协议提出更高的要求。原本我们使用JSON作为我们的数据序列化协议。JSON的语言支持丰富，而且数据可读性强，然而在大量数据传输和存储的情况下，效率仍然有待提升。JSON为了支持数据的可读性，添加了许多的描述性数据，然而这部分数据对用户来说是没有价值的。 因此我们选择了MessagePack——一种二进制的数据序列化协议来作为我们的基本数据交换协议。有了MessagePack序列化协议的支持，我们可以使得数据的对象的传输和存储更加高效，从而提高Lest系统的数据读写效率。

## 设计目标

为了使得Hermes能够更好的为Lest服务，我们设定了如下的设计目标：

* 更加轻量级
* 支持对象序列化
* 语言无关性

更加轻量级的数据交换协议是Hermes设计的一个重要目标，它需要为数据的高效传输和存储提供基本的支持。对象序列化是另一个重要目标，在我们的Lest客户端上需要支持List，Map等数据对象。此外，Hermes需要支持在多种语言之间的数据交换，做到语言无关性。因为我们的客户端是java实现的，我们的服务器端是C实现的，需要在这两种语言之间进行数据交互，必须做到数据交换协议是构建于语言之上，使得它具有语言无关性。当前可以支持Java，C，PHP等语言之间的数据交换。

## 关于数据交换格式

​	数据交换格式顾名思义就是在端和端之间进行数据传输的格式。根据交换数据的类型，可以将其分为两类，一类是比较直观的数据格式，易于阅读和构建，当前比较流行的直观数据交换格式有JSON，XML，YAML等。当前随着js等前端技术的一路高歌，JSON协议更加是如日中天，尤其是在前端和一些业务端的数据交互上。然而在面对数据存储，等底层的数据业务上，JSON这些数据交互格式任然显的有些重，为了能使人类更直观的了解数据信息，它的格式加入了很多对机器来说冗余的信息。所以另一种更加适合底层数据存储的格式是二进制的数据交换格式，如Google的Protocol Buffer，MessagePack等，这些数据交换格式往往更加轻量级，因此数据的传输和存储也更加高效，但是他们的缺点也很明显，对人类不够友好。除此之外，还有集二者与一身的Thrift框架，它在服务端和客户端通信的时候，既支持文本格式的协议，又支持二进制格式的协议，不过为了节约带宽，提高传输效率，一般情况下都是使用二进制协议，它当前支持的二进制协议有几种：BinaryProtocol——二进制编码格式；TCompactProtocol——高效、密集的二进制编码格式；TJSONProtocol——JSON数据交换格式。所以各种数据交换格式都有自己的优势和劣势，总有一款适合我们。

## 总体流程

Hermes根据协议对象进行序列化和反序列化，并在服务端构建对象树的流程如下图所示。

![img](file:///F:/%E5%BE%AE%E4%BA%91%E5%90%8C%E6%AD%A5/%E6%96%87%E6%A1%A3/Hermes/Hermes%E6%B5%81%E7%A8%8B.png?lastModify=1497583416)

根据数据的流向可以分为2个过程：

- 客户端->服务器端
  1. 客户端根据协议将对象序列化为二进制数据流
  2. 二进制数据传输到服务器端
  3. 服务器端根据协议将对象反序列化为对象树结构
- 服务器端->客户端
  1. 服务器端将对象树根据协议序列化为二进制数据流
  2. 二进制数据传输到客户端
  3. 客户端根据协议将二进制数据流反序列化为客户端对象

由以上流程可以看出，Hermes是构建在MessagePack协议之上的一种对象数据协议。数据序列化的基本单元是一个对象类型（客户端是java对象，服务器端是一颗对象树，我们一般称为HMS对象）。通过这样的对象数据协议，可以使得C服务器程序和java客户端程序在更抽象的对象数据上进行数据通信，从而简化了服务器端数据对象的处理。可以想象如果按照传统的kv数据类型，那么客户端的对象数据在服务器端的映射往往是一段json字符串。它在服务器端的操作是非常有限的。这些kv的服务器端往往只起到了一个数据存储的作用，而且在客户端和服务器间往往需要重复传输大量的数据。在服务器端构建出HMS对象就可以把很多客户端的操作放到服务器端，从而避免了大量的数据传输。

## MessagePack协议扩展

​	MessagePack是一种对象序列化协议，它通过二进制的方式对数据对象进行序列化和反序列化，因此能够提供比Json，XML更高的传输和存储效率。协议格式如下：

| 格式名称            | 首字节(二进制) | 首字节(十六进制)   |
| :-------------- | -------- | ----------- |
| positive fixint | 0xxxxxxx | 0x00 - 0x7f |
| fixmap          | 1000xxxx | 0x80 - 0x8f |
| fixarray        | 1001xxxx | 0x90 - 0x9f |
| fixstr          | 101xxxxx | 0xa0 - 0xbf |
| nil             | 11000000 | 0xc0        |
| (never used)    | 11000001 | 0xc1        |
| false           | 11000010 | 0xc2        |
| true            | 11000011 | 0xc3        |
| bin 8           | 11000100 | 0xc4        |
| bin 16          | 11000101 | 0xc5        |
| bin 32          | 11000110 | 0xc6        |
| **ext 8**       | 11000111 | 0xc7        |
| **ext 16**      | 11001000 | 0xc8        |
| **ext 32**      | 11001001 | 0xc9        |
| float 32        | 11001010 | 0xca        |
| float 64        | 11001011 | 0xcb        |
| uint 8          | 11001100 | 0xcc        |
| uint 16         | 11001101 | 0xcd        |
| uint 32         | 11001110 | 0xce        |
| uint 64         | 11001111 | 0xcf        |
| int 8           | 11010000 | 0xd0        |
| int 16          | 11010001 | 0xd1        |
| int 32          | 11010010 | 0xd2        |
| int 64          | 11010011 | 0xd3        |
| **fixext 1**    | 11010100 | 0xd4        |
| **fixext 2**    | 11010101 | 0xd5        |
| **fixext 4**    | 11010110 | 0xd6        |
| **fixext 8**    | 11010111 | 0xd7        |
| **fixext 16**   | 11011000 | 0xd8        |
| str 8           | 11011001 | 0xd9        |
| str 16          | 11011010 | 0xda        |
| str 32          | 11011011 | 0xdb        |
| array 16        | 11011100 | 0xdc        |
| array 32        | 11011101 | 0xdd        |
| map 16          | 11011110 | 0xde        |
| map 32          | 11011111 | 0xdf        |
| negative fixint | 111xxxxx | 0xe0 - 0xff |

​	MessagePack协议类型提供了integer，Nil，Boolean，Float，String，Binary，Array，Map等基本类型的支持，此外还支持Extension的扩展类型。为了方便对 java对象进行序列化，我们将重新定义可扩展类型Ext，将它表示为一个java对象类型。Ext协议格式主要由4各部分组成：协议头，类型，数据长度，数据。

8个数据字节的固定格式的Ext:

```
    +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    |  0xd7  |  type  |                                  data                                 |
    +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
```

8位长度字节格式的Ext:

```
    +--------+--------+--------+--------+========+
    |  0xc8  |YYYYYYYY|YYYYYYYY|  type  |  data  |
    +--------+--------+--------+--------+========+
```

​	将Ext中的协议头重新定义为java类对象的协议头，同时将type类型定义为备用类型，data为对象序列化后的二进制数据值，其大小由Ext的长度存储字节表示。通过java的反射技术，可以将java对象中的所有属性，一一列出，然后再根据以上协议将所有属性-值序列化为二进制的数据，作为data嵌入到一个Ext的data字段中，并选择相应的Ext协议头类型，同时设置长度存储字节的二进制值。这样就可以得到一个对象的二进制表示。

##数据对象

​	当前Hermes主要是为我们另一套去内存化的分布式存储系统服务的，所以它当前序列化主要支持2种类型List和Map。为了方便服务端的数据操作，我们对他们进行包装，添加了一个String类型的key，一个int类型的start，一个int类型的end，最后一个属性才是真正的ArrayList类型和HashMap类型的数据结构。其中start和end是为了List的映射范围，在进行List的区间查询的时候，通过设置这两个字段可以指定相应的查询区间，避免了大量无效数据的传输，提高了数据的传输效率。


* **List对象**

  ~~~~java
  Class LestListObject<T>{
    String key;
    int start;
    int end;
    ArrayList<T> value = new ArrayList<T>();
  }
  ~~~~

  ​

* **Map对象**

  ~~~~java
  Class LestMapObject<T>{
    String key;
    int start;
    int end;
    Map<K, T> value = new HashMap<K, T>();
  }
  ~~~~


## java端序列化

​	通常情况下，待序列化对象通常包括2种类型的数据成员：

* 原生数据类型：

  原生数据类型是java客户端所支持的基本的数据类型，主要包括byte类型（8字节），short类型（16字节），int类型（32字节），long类型（64字节），float类型（单精度浮点型），double类型（双精度浮点型），char类型(字符类型)，boolean（布尔型）。

* 对象数据类型

  为了方便协议的解析，将对象数据类型分为两种，普通对象类型，List和Map对象类型。

  通过java类的反射方法，可以获取类中的所有属性，若属性是原生类型则直接根据协议进行序列化；若对象是List或Map类型，则遍历List和Map。若属性是对象类型，则将对象进行递归反射，直到属性为原生类型或List或Map类型。

  ~~~java
  Class LestListObject<String>{
    String key = "hello";
    int start = 0;
    int end = 0;
    ArrayList<String> value = ["hello world"];
  }
  ~~~

  如上所示的一个List对象，它的key属性是一个String类型的字符串"hello"，start属性是一个int类型的值0，end属性是一个int类型的值0，value是一个String类型的字符串数组。通过序列化方法进行序列化可以得到如下的一串十六进制数据流。

  ~~~
  C7 31 00 A3 6B 65 79 A5 68 65 6C 6C 6F A5 73 74 61 72 74 D2 00 00 00 00 A3 65 6E 64 D2 00 00 00 00 A5 76 61 6C 75 65 91 AB 68 65 6C 6C 6F 20 77 6F 72 6C 64
  ~~~

  根据协议可以将数据流分为5段：

  * ~~~
    C7 31 00 
    ~~~

    协议头为0xC7，根据我们对MessagePack协议的重定义，它表示一个8个字节范围长度的对象类型

    0x37，表示后接对象的长度为55

    0x00，作为保留字段，当前未定义

  * ~~~
    A3 6B 65 79 A5 68 65 6C 6C 6F 
    ~~~

    协议头为0xA3，表示后接长度为3的一个String

    0x6B 0x65 0x79，表示字符串"key"

    协议头为0xA5，表示长度为5的一个String

    0x68 0x65 0x6C 0x6C 0x6F，表示字符串"hello"，就是我们在对象中设置的key值

  * ~~~~
    A5 73 74 61 72 74 D2 00 00 00 00
    ~~~~

    协议头为0xA5，表示后接一个长度为5的String

    0x73 0x74 0x61 0x72 0x74，表示字符串"start"

    协议头0xD2，表示后接一个int32的值

    0x00 0x00 0x00 0x00表示0(int32)

  * ~~~~
    A3 65 6E 64 D2 00 00 00 00 
    ~~~~

    协议头0xA3，表示后接一个长度为3的String

    0x65 0x6E 0x64，表示字符串"end"

    协议头0xD2，表示后接一个int32的值

    0x00 0x00 0x00 0x00表示0(int32)

  * ~~~
    A5 76 61 6C 75 65 91 AB 68 65 6C 6C 6F 20 77 6F 72 6C 64
    ~~~

    协议头0xA5，表示后接一个长度为5的String

    0x76 0x61 0x6C 0x75 0x65，表示字符串"value"

    协议头0x91，表示一个长度为1的Array

    协议头0xAB，表示后接一个长度为11的字符串

    0x68 0x65 0x6C 0x6C 0x6F 0x20 0x77 0x6F 0x72 0x6C 0x64，表示字符串"hello world"

## java端反序列化

​	客户端在进行查询操作时，通常服务器端会返回一串经过序列化的二进制数据流，客户端需要对该数据进行反序列化，重新生成相应的java对象。 java客户端的反序列化过程是序列化过程的一个逆向操作，按着从左往右的顺序扫描二进制数据流，一次扫描操作的基本单位是一个协议单元。一个协议单元通常包括一个协议头和一串协议数据。其中协议数据又可以包含若干个协议单元，并且可以根据对象数据的类型不断递归。

~~~
			协议头							|				协议数据
~~~

​	反序列化首先会扫描一个协议头，根据协议头的类型再去解析协议数据。当前客户端的协议头主要支持一下类型：

|  客户端类型  |                   协议类型                   |
| :-----: | :--------------------------------------: |
| INTEGER | uint8, int8,  uint16, int16, uint32, int32 |
|  LONG   |              uint64, int64               |
|   RAW   |  bin8, bin16, bin32, str8, str16, str32  |
|  ARRAY  |             array16, array32             |
|   MAP   |               map16, map32               |
|   NIL   |                   nil                    |
| BOOLEAN |                 boolean                  |
|  FLOAT  |                  float                   |
| DOUBLE  |                  double                  |
|   EXT   |            ext8, ext16, ext32            |

## 对象树

​	java客户端可以通过对象来表示一个数据，然而我们的服务器端是通过C语言来实现，不存在对象的概念，因此我们提出了一个对象树的概念，来映射客户端的对象。对象树是由一个根节点，若干子节点的多叉树构成，每个节点对应了客户端对象中的一个属性。节点和节点之间通过next或child指针向连。通常情况下，同一对象中的数据属于兄弟节点，通过next指针连接。若某子节点是一个对象节点，则该节点有包含了一颗新的对象子树，如此这般不断递归迭代，直到遍历完所有的对象节点。 ![对象树](对象树.png)

​	如上图所示在服务器端构建了一个与客户端List对象对应的对象树结构。上图的对象树包括4个子节点，从左往右依次对应了java类对象中的key，start，int，value。其中value又通过一颗新的子树来表示一个List结构，子树中的每个节点表示List中的每个数据对象。通过这样的一个对象树的结构，可以轻松的在服务器端完成各种数据操作，大大简化了数据操作的复杂程度。对象数是Hermes的一个重要组成部门，没有对象树，我们在服务器端的很多操作都无法顺利的完成。

​	服务器端对象树的构建也即二进制数据流在服务器端反序列化的过程。为了方便对象树的构建，设定每个子节点为一个结构体对象，用于表征一个对象数据，我们称它为hms_object。结构体对象是一个key-value结构，它包含了一个key值，一个value值，另外还有指向兄弟节点的指针next以及指向子节点的指针child。

~~~~c
struct hms_object{
  bool_t is_key;
  object_type key_type;
  object_type value_type;
  struct hermes_object *next;
  struct hermes_object *child;
  object_value value;
  int obj_len;
  int key_len;
  object_value key;
}
~~~~

​	为了支持协议中的数据类型，识别key和value中的数据，在hms_obj中设置了相应的数据类型，当前hermes支持的数据类型如下：

~~~
HMS_TYPE_STR = 0x00
HMS_TYPE_BIN = 0x01
HMS_TYPE_INT8 = 0x02
HMS_TYPE_UINT8 = 0x03
HMS_TYPE_INT16 = 0x04
HMS_TYPE_UINT16 = 0x05
HMS_TYPE_INT32 = 0x06
HMS_TYPE_UINT32 = 0x07
HMS_TYPE_INT64 = 0x08
HMS_TYPE_UINT64 = 0x09
HMS_TYPE_FLOAT = 0x0A
HMS_TYPE_DOUBLE = 0x0B
HMS_TYPE_FALSE = 0x0C
HMS_TYPE_TRUE = 0x0D
HMS_TYPE_NIL = 0x0E
HMS_TYPE_ARRAY = 0x0F
HMS_TYPE_MAP = 0x10
HMS_TYPE_EXT = 0x11
HMS_TYPE_POSITIVE_INT = 0x12
HMS_TYPE_NEGATIVE_INT = 0x13
~~~

​	通过以上的自定义的数据类型，可以用于表示hms_obj对象中的数据类型，从而能够从value中取到正确的数据。为了能够表示多种类型的数据，value设置了一个联合类型如下：

~~~c
typedef union object_value{
  char *str_val;
  ubyte_t *bin_val;
  int8_t int8_val;
  uint8_t uint8_val;
  int16_t int16_val;
  uint16_t uint16_val;
  int32_t int32_val;
  uint32_t uint32_val;
  int64_t int64_val;
  uint64_t uint64_val;
  float float_val;
  double double_val;
  bool_t bool_val;
} object_value;
~~~

​	通过object_type和object_ value的配合，根据object_type的类型，从object_value中获得正确的数据。因此object_type和object_value是一个统一的整体单元，二者联合才能提供服务，仅仅根据其中的任一元组都没有办法获得到真正的数据。

## 对象树构建

​	服务器端接收到的是一串二进制数据流，为了构建服务器端的对象树，我们需要采用适当的方法去遍历该数据流。为此，我们提出了一个二进制流的扫描器结构，该结构可以在二进制数据流上从左向右解析滑动解析数据流，而且无需回退，一次遍历便可以完成数据解析,从而构建出一颗对象树。扫描器中包含了三个指针root，node，buf，一个偏移off。其中root是指向对象树的根节点，node指向对象树当前的构造节点，buf指向数据流的缓存，off是数据流缓存上的偏移。

~~~c
struct scanner{
  struct hms_object *root;
  struct hms_object *node;
  ubyte_t *buf;
  int off;
}
~~~

​	  基于这样的一个结构，就可以实时的标识出对象树构建节点的位置，以及当前的数据流偏移。每次数据解析操作的基本单元是一个二元组<协议头，协议数据>。在每次新的解析操作中，扫描器的off偏移指向数据流的协议头，根据协议头的类型给它适配相应的解析方法，并构造相应的对象树节点。若是基本数据类型，则直接构造对象节点，并为它设置相应的数据，调整off指针。若是对象数据类型，则需要递归构造对象树，而且往往需要设置child指针。值得注意的是，我们的协议对象规则是<属性，对象>模式，即前一个是树属性名称，后一个是数据对象，它们分别对应了结构树对象中的key和value。因此在进行二进制数据解析的时候，对象数据的解析也需要遵循这样的规则，首先会解析对象的属性值，然后再解析对象数据，从而构建一个完整的对象节点。当然对应普通的基本数据只需要解析value即可，如在List对象中的所有子节点。

 ![对象树构建](对象树构建.png)

## 对象树序列化

​	对象树的序列化需要将对象树序列化成二进制的数据流对象，才能将数据发送给客户端，它是对象树构建的一个逆向工程。为了序列化对象树，我们首先需要访问对象树中的每个数据节点。在内存中实际对象树结构可以看成一颗二叉树，其中child为左孩子节点，next为右孩子节点。

 ![真实的对象树](真实的对象树.png)

​	为了访问对象树中的所有数据节点，遍历对象树的主要有两种方式，深度优先遍历和广度优先遍历。严格意义上来讲，我们需要采用深度优先遍历的方式来访问对象树的数据节点，这样可以和客户端的对象属性序列化顺序保持一致，从而保证得到的二进制数据的有效性。

​	采用深度优先遍历的节点访问顺序：

~~~~
root->1->4->7->5->6->2->3
~~~~

​	采用广度优先遍历的节点访问顺序：

~~~~
root->1->4->2->7->5->3->6
~~~~

​	在如上图所示的对象树结构下，如果我们采用广度优先遍历则会导致序列化后的二进制数据混乱。因为根据Hermes协议的定义，协议数据应该紧跟协议头，而通过广度优先遍历的方式访问的节点数据则打乱了这种定义顺序，将导致客户端无法解析，所以我们应该使用深度优先遍历作为我们访问数据节点的方法。然而，深度优先遍历往往有个很恶心的问题（对，就是遍历栈）。试想一下，如果node1节点是一个List对象，它的child节点node4，以及node4的next节点node5，node6，...（假装后面还有好多next节点）都是List对象的子对象，那么node1节点的遍历栈的深度就是List对象的长度，那意味着我们的遍历要做List长度次的递归。List短一点还好，如果List很长的话，效率简直不能忍，那太可怕了。所以，纯粹的深度优先遍历在这种情况下的数据访问设计是不可接受的。

​	为了解决递归栈的问题，让我们再次回顾一下，java客户端中的List对象结构，并将它映射成服务器端的对象树结构如下所示。

  ![List映射结构树](List映射结构树.png)

​	对如上结构进行深度优先遍历，可以得到如下的节点访问顺序：

~~~~
root->key->start->end->value->data1->data2->data3->...
~~~~

​	对如上结构进行广度优先遍历，可以得到如下的节点访问顺序：

~~~
root->key->start->end->value->data1->data2->data3->...
~~~

​	通过以上的分析，我们发现对该结构的广度优先遍历和深度优先遍历的顺序是一致的，那也意味着对于固定特定格式的List和Map类型就无所谓广度还是深度遍历，因此可以选用广度优先遍历方法来替代深度优先遍历，从而避免了深度优先遍历下遍历栈过深的情况。

​	然而这只是一种临时的替代策略，在普遍情况下，深度优先遍历和广度优先遍历得到的结果往往是不同的，因此，为了保证java客户端对象序列化的普适性，我们任然需要选择深度优先遍历来作为我们的基本数据遍历方法，不过在遍历栈过深的问题上，我们通过循环，而非递归的方式来遍历数据节点，从而避免了遍历大量List或Map数据节点时不断增加遍历栈深度的问题。

​	经过深入的分析，我们发现造成深度优先遍历的遍历栈过深问题的根源在于List和Map等链式对象存储结构上。因为每次深度优先遍历的对象是一个数据对象节点，而且List和Map中的每个数据对象都是通过next相连，所以在List或Map中的每个数据节点都会被作为深度优先遍历的对象，从而大大增加遍历栈的深度。经过仔细的思考，我们发现List和Map中的每个数据节点可以视为同一维度上的数据对象，而不作进一步的递归。基于此，我们提出一种递归和循环相互结合的深度递归遍历方法：

 ![递归循环遍历](递归循环遍历.png)

~~~
1. 开始遍历
2. 当前对象节点是不是List或Map结点，若是则执行3，否则执行4
3. 当前节点是List或Map对象结点，以该结点的第一个子结点作为循环的起始结点，对象的长度作为循环的长度，循环
   遍历对象的所有子结点，并标记当前结点的子节点已经遍历完成
4. 当前对象结点是普通对象结点，正常访问对象中的数据
5. 当前对象结点是否存在child或next结点，若不存在则遍历结束；否则设置当前节点为next结点或child结点，继续    执行步骤2
~~~

## 条件查询树

为了Hermes使支持基于索引的条件查询，需要为其构建相应的条件查询树。Hermes条件查询树是一棵类二叉树，Lest当前仅支持较为简单的查询条件如: >, <, =, &, |等，其中>, <, =是针对索引的基本查询条件，&, |是对条件查询结果做并集和交集。

查询条件如下例：

~~~~
((((a > 0) & (b < 3)) | (c < 7) | (e > 9)) & (d = 8))
~~~~

 ![查询树](查询树.png)

#### 客户端条件查询MPQL

为了方便客户端的查询条件的构建，在客户端提供了相应的条件查询方法:

| 方法名               | 说明         |
| :---------------- | :--------- |
| MPQL_Bigger_Int   | int类型大于    |
| MPQL_Bigger_Long  | long类型大于   |
| MPQL_Smaller_Int  | int类型小于    |
| MQPL_Smaller_Long | long类型小于   |
| MQPL_Equal_Int    | int类型等于    |
| MQPL_Equal_Long   | long类型等于   |
| MQPL_Equal_String | string类型等于 |
| MQPL_Begin_And    | 与条件开始(&)   |
| MQPL_Begin_Or     | 或条件开始(\|)  |
| MQPL_End          | 条件结束       |

根据以上的MPQL的条件查询API可以通过如下方法构建查询条件:

~~~
MessagePackBufferPacker pk = = new MessagePackBufferPacker();
MPQL_Begin_And(pk, 2);
MPQL_Begin_Or(pk, 3);
MPQL_Begin_And(pk,2);
MPQL_Bigger_Int(pk, "a", 0);
MPQL_Smaller_Int(pk, "b", 3);
MPQL_End(pk);
MPQL_Smaller_Int(pk, "c", 7);
MPQL_Bigger_Int(pk, "e", 9);
MPQL_End(pk);
MPQL_Equal_Int(pk, "d", 8);
MPQL_End(pk);
~~~

#### MPQL解析

参考Hermes服务端解析

#### MPQL查询

* 基本查询

  基本查询包括>, <, =3个查询条件，需要根据索引条件逐级查询插入跳表、冻结跳表以及线段跳表。

* 并集和交集

  根据查询条件&和|，需要对查询结果进行并集或交集。

* 优先级

  MPQL的优先级可以对查询树进行DFS(深度优先搜索)来实现。



## 总结

​	Hermes数据通信协议是当前我们的存储系统中的一个重要模块，它作为各个业务的数据通信客户端和数据服务端进行数据传输，提供了高效的数据传输和存储方式。当前Hermes主要支持客户端的数据的序列化和反序列化，服务器端数据的序列化和反序列化，同时为底层的高效数据存储提供了天然的优势。此外，客户端还支持基于索引的多条件查询功能，大大简化了客户端的使用复杂度。